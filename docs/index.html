<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive V.I.R.P. Circuit Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc; /* slate-50 */
            --bg-tertiary: #f1f5f9;  /* slate-100 */
            --bg-accent: #f0f9ff;   /* sky-50 */
            --bg-accent-nested: #ecfeff; /* cyan-50 */
            --text-primary: #1e293b; /* slate-800 */
            --text-secondary: #475569; /* slate-600 */
            --text-accent: #0c4a6e; /* sky-800 */
            --border-primary: #e2e8f0; /* slate-200 */
            --border-accent: #bae6fd;  /* sky-200 */
            --border-focus: #3b82f6; /* blue-500 */
            --heading-color: #1d4ed8; /* blue-700 */
            --button-text: #ffffff;
            --scrollbar-thumb: #94a3b8;
            --scrollbar-track: #f1f5f9;
            --bg-animated-light: linear-gradient(-45deg, #e0f2fe, #f0f9ff, #ecfeff, #f0fdf4);
            --bg-main-container-light: rgba(255, 255, 255, 0.7);
            --border-main-container-light: rgba(255, 255, 255, 0.2);
            --highlight-stroke: #2563eb; /* blue-600 */
            --hover-stroke: #ea580c; /* orange-600 */
        }

        html.dark {
            --bg-primary: #1e293b; /* slate-800 */
            --bg-secondary: #334155; /* slate-700 */
            --bg-tertiary: #0f172a;  /* slate-900 */
            --bg-accent: #1e293b;   /* slate-800 */
            --bg-accent-nested: #27374d; /* custom */
            --text-primary: #e2e8f0; /* slate-200 */
            --text-secondary: #94a3b8; /* slate-400 */
            --text-accent: #7dd3fc; /* sky-300 */
            --border-primary: #475569; /* slate-600 */
            --border-accent: #38bdf8;  /* sky-400 */
            --border-focus: #60a5fa; /* blue-400 */
            --heading-color: #60a5fa; /* blue-400 */
            --button-text: #ffffff;
            --scrollbar-thumb: #475569;
            --scrollbar-track: #1e293b;
            --bg-animated-dark: linear-gradient(-45deg, #0c4a6e, #0f172a, #1e293b, #334155);
            --bg-main-container-dark: rgba(30, 41, 59, 0.7);
            --border-main-container-dark: rgba(71, 85, 105, 0.3);
            --highlight-stroke: #60a5fa; /* blue-400 */
            --hover-stroke: #f97316; /* orange-500 */
        }
        
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            transition: color 0.3s;
            background-size: 400% 400%;
            animation: gradient-animation 20s ease infinite;
            background-image: var(--bg-animated-light);
        }
        html.dark body {
            background-image: var(--bg-animated-dark);
        }

        .main-container {
            background-color: var(--bg-main-container-light);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--border-main-container-light);
        }
        html.dark .main-container {
            background-color: var(--bg-main-container-dark);
            border: 1px solid var(--border-main-container-dark);
        }

        .component-group {
            border-left: 3px solid #1e40af; /* blue-800 */
            background-color: var(--bg-accent);
        }
        .nested-component-group {
            border-left: 3px solid #0e7490; /* cyan-700 */
            background-color: var(--bg-accent-nested);
        }
        .control-panel { background-color: var(--bg-secondary); }
        .canvas-bg { background-color: var(--bg-secondary); }
        input { background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-primary); }
        input:focus { --tw-ring-color: var(--border-focus); border-color: var(--border-focus); }
        
        .header-text {
            background-image: linear-gradient(45deg, #3b82f6, #1d4ed8);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        html.dark .header-text {
             background-image: linear-gradient(45deg, #60a5fa, #93c5fd);
        }

        .subheader-text { color: var(--text-secondary); }
        .border-main { border-color: var(--border-primary); }
        .text-main { color: var(--text-primary); }
        .text-light { color: var(--text-secondary); }
        .text-accent-color { color: var(--text-accent); }
        .branch-bg { background-color: var(--bg-primary); }
        .branch-border { border-color: var(--border-accent); }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="flex items-start justify-center min-h-screen p-4 sm:p-6">

<div class="main-container p-6 sm:p-8 rounded-2xl shadow-lg w-full max-w-6xl relative">
    <!-- Spinning Fish GIF -->
    <div class="absolute top-6 left-6 w-24 z-10">
        <div class="tenor-gif-embed" data-postid="2672489223534272224" data-share-method="host" data-aspect-ratio="1.75352" data-width="100%"><a href="https://tenor.com/view/low-poly-spinning-fish-low-poly-spinning-fish-green-sunfish-gif-2672489223534272224">Low-poly Spinning GIF</a>from <a href="https://tenor.com/search/low-poly-gifs">Low-poly GIFs</a></div>
    </div>


    <header class="text-center mb-6 pb-4 border-b border-main">
        <h1 class="text-3xl sm:text-4xl font-bold header-text">Interactive V.I.R.P. Circuit Calculator ⚡</h1>
        <p class="subheader-text mt-1">Build, analyze, and interact with complex circuits.</p>
    </header>
    
    <p class="text-center text-sm text-light mb-4">This calculator handles any series-parallel circuit, including complex nested and ladder circuits. Bridge circuits require a different analysis method.</p>

    <!-- Canvas for Circuit Diagram -->
    <div class="canvas-bg rounded-lg p-2 mb-6 overflow-x-auto relative">
        <canvas id="circuit-canvas" class="h-auto"></canvas>
        <button id="reset-view-btn" onclick="resetIsolationView()" class="absolute top-2 right-2 bg-blue-500 text-white font-semibold py-1 px-3 rounded-lg hover:bg-blue-600 transition-all shadow-sm text-sm" style="display: none;">Show Full Circuit</button>
    </div>

    <!-- Main Controls -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <!-- Voltage Input -->
        <div class="control-panel p-4 rounded-lg">
            <label for="voltage" class="block font-semibold text-main mb-2">Source Voltage (V)</label>
            <input type="number" id="voltage" placeholder="e.g., 12" value="24" oninput="drawAndCalculate()" class="w-full p-2 border rounded-md focus:ring-2 transition">
        </div>

        <!-- Add Components & Examples -->
        <div class="control-panel p-4 rounded-lg md:col-span-2">
            <h2 class="font-semibold text-main mb-2">Circuit Builder</h2>
            <div class="flex flex-wrap gap-3 mb-4">
                 <button onclick="addComponent('resistor')" class="flex-grow bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition-all shadow-sm transform hover:scale-105">+ Add Series Resistor</button>
                 <button onclick="addComponent('parallel')" class="flex-grow bg-sky-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-sky-700 transition-all shadow-sm transform hover:scale-105">+ Add Parallel Group</button>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4 mt-4 pt-4 border-t border-main">
                <div>
                    <h2 class="font-semibold text-main mb-2">Examples</h2>
                    <div class="flex flex-col gap-3">
                         <button onclick="buildLadderCircuit()" class="w-full bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-all shadow-sm">Load Ladder Example</button>
                         <button onclick="buildNestedExample()" class="w-full bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-purple-600 transition-all shadow-sm">Load Nested Example</button>
                    </div>
                </div>
                 <div>
                    <h2 class="font-semibold text-main mb-2">Circuit Controls</h2>
                    <div class="flex flex-col gap-3">
                         <button onclick="simplifyCircuit()" class="w-full bg-teal-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-teal-600 transition-all shadow-sm">Simplify Circuit</button>
                         <button onclick="clearCircuit()" class="w-full bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-all shadow-sm">Clear Circuit</button>
                    </div>
                </div>
            </div>
            <!-- START: SAVE/LOAD/IMPORT/EXPORT BUTTONS -->
            <div class="grid grid-cols-2 gap-3 mt-4 pt-4 border-t border-main">
                 <button onclick="saveCircuit()" class="w-full bg-emerald-500/80 text-white font-semibold py-1 px-3 text-sm rounded-lg hover:bg-emerald-600/80 transition-all shadow-sm">Save to Browser</button>
                 <button onclick="loadCircuit()" class="w-full bg-amber-500/80 text-white font-semibold py-1 px-3 text-sm rounded-lg hover:bg-amber-600/80 transition-all shadow-sm">Load from Browser</button>
                 <button onclick="exportCircuit()" class="w-full bg-sky-500/80 text-white font-semibold py-1 px-3 text-sm rounded-lg hover:bg-sky-600/80 transition-all shadow-sm">Export to File</button>
                 <button onclick="importCircuit()" class="w-full bg-indigo-500/80 text-white font-semibold py-1 px-3 text-sm rounded-lg hover:bg-indigo-600/80 transition-all shadow-sm">Import from File</button>
            </div>
            <!-- END: SAVE/LOAD/IMPORT/EXPORT BUTTONS -->
        </div>
    </div>
    
    <!-- Dynamic Component Inputs -->
    <div id="circuit-builder" class="space-y-4 mb-6"></div>
    
    <!-- Calculate Button -->
    <div class="text-center my-6">
        <button onclick="drawAndCalculate({force: true})" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-3 px-12 rounded-lg hover:bg-blue-700 transition-all shadow-lg transform hover:scale-105 text-lg">Calculate V.I.R.P.</button>
    </div>
    
    <!-- Naming Convention Toggle -->
    <div class="flex justify-end items-center mb-4">
        <span class="text-sm font-medium text-light mr-3">Resistor Naming:</span>
        <button id="naming-toggle-btn" onclick="toggleNamingConvention()" class="bg-indigo-500 text-white font-semibold py-1 px-3 rounded-lg hover:bg-indigo-600 transition-all shadow-sm text-sm">
            Sequential (R1, R2...)
        </button>
    </div>

    <!-- Results Table -->
    <div id="results-container" class="overflow-x-auto"></div>

    <!-- Explanation Section -->
    <div id="explanation-section" class="mt-4 text-center" style="display: none;">
        <button id="explain-btn" onclick="toggleExplanation()" class="bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 transition-all shadow-sm">
            Explain Equations
        </button>
        <div id="explanation-content" class="mt-4 p-4 rounded-lg text-left bg-tertiary border-main" style="display: none; background-color: var(--bg-tertiary);">
            <!-- Explanation will be injected here -->
        </div>
    </div>

    <!-- Cat Button Section -->
    <div class="text-center mt-8 pt-6 border-t border-main">
        <p class="text-light mb-3">Feeling overwhelmed by all the calculations?</p>
        <button onclick="showCatPopup()" class="bg-pink-500 text-white font-semibold py-2 px-6 rounded-lg hover:bg-pink-600 transition-all shadow-lg transform hover:scale-105">Take a Break with a Random Cat 🐱</button>
    </div>
</div>

<!-- Cat Popup Modal -->
<div id="cat-popup" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 transition-opacity duration-300" style="display: none;">
    <div class="bg-primary p-4 rounded-lg shadow-xl text-center relative max-w-md w-full mx-4 transform scale-95 transition-transform duration-300">
        <button onclick="hideCatPopup()" class="absolute -top-2 -right-2 text-white bg-red-500 hover:bg-red-600 w-8 h-8 rounded-full flex items-center justify-center text-lg font-bold shadow-lg">&times;</button>
        <h3 class="text-xl font-semibold mb-4 text-main">Here's a random cat for you!</h3>
        <div id="cat-image-container" class="w-full h-80 bg-tertiary rounded-md flex items-center justify-center overflow-hidden">
            <p class="text-light animate-pulse">Loading a cute cat...</p>
        </div>
        <button onclick="loadNewCat()" class="mt-4 bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-blue-700 transition-all shadow-sm">Get Another Cat</button>
    </div>
</div>


<script>
    // --- DATA STRUCTURE & STATE ---
    let circuit = [];
    let componentIdCounter = 0;
    let useSequentialNaming = true;
    const canvas = document.getElementById('circuit-canvas');
    const ctx = canvas.getContext('2d');

    // --- INTERACTIVITY STATE ---
    let drawableComponents = [];
    let isolatedComponentPath = null;
    let hoveredComponentPath = null;

    // --- THEME MANAGEMENT ---
    function applyTheme() {
        const theme = localStorage.getItem('theme');
        if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    }

    function toggleDarkMode() {
        document.documentElement.classList.toggle('dark');
        if (document.documentElement.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
        } else {
            localStorage.setItem('theme', 'light');
        }
        drawAndCalculate({force: true});
    }

    applyTheme(); // Apply theme on initial script load to prevent flashing

    // --- CORE COMPONENT MANAGEMENT ---

    function getComponentByPath(path) {
        let currentCollection = circuit;
        let component = null;

        for (let i = 0; i < path.length; i++) {
            const componentIndex = path[i];
            
            if (!currentCollection || componentIndex >= currentCollection.length) {
                return null; 
            }
            component = currentCollection[componentIndex];

            if (component && component.type === 'parallel') {
                if (i + 1 >= path.length) {
                    break; 
                }
                const branchIndex = path[i + 1];
                
                if (!component.branches || branchIndex >= component.branches.length) {
                    return null;
                }
                currentCollection = component.branches[branchIndex];
                i++; // Manually skip the branch index we just used
            }
        }
        return component;
    }

    function getParentByPath(path) {
        if (path.length <= 1) return { parent: circuit, index: path[0] };
        
        let currentLevel = circuit;
        let parent = circuit;
        let lastIndex = path[0];

        for (let i = 0; i < path.length - 1; i++) {
            const index = path[i];
            parent = currentLevel[index] || currentLevel;
            lastIndex = index;
            if (parent.type === 'parallel' && i < path.length - 2) {
                const branchIndex = path[++i];
                currentLevel = parent.branches[branchIndex];
            } else {
                currentLevel = parent;
            }
        }
        return { parent: currentLevel, index: path[path.length-1] };
    }

    function createComponent(type) {
        componentIdCounter++;
        if (type === 'resistor') {
            return { id: componentIdCounter, type: 'resistor', value: null };
        }
        if (type === 'parallel') {
            return { id: componentIdCounter, type: 'parallel', branches: [[], []] };
        }
    }
    
    function addComponent(type, pathStr = '[]') {
        const path = JSON.parse(pathStr);
        const newComponent = createComponent(type);
        if (path.length === 0) {
            circuit.push(newComponent);
        } else {
            let parentGroup = circuit;
            let targetBranch = null;

            for(let i = 0; i < path.length; i++) {
                if(i % 2 === 0) { // component index
                    parentGroup = parentGroup[path[i]];
                } else { // branch index
                    targetBranch = parentGroup.branches[path[i]];
                    parentGroup = targetBranch;
                }
            }
            targetBranch.push(newComponent);
        }
        renderControls();
        drawAndCalculate();
    }

    function removeComponent(pathStr) {
        const path = JSON.parse(pathStr);
        if (!path || path.length === 0) return;

        const indexToRemove = path[path.length - 1];
        let parentCollection;

        if (path.length === 1) {
            parentCollection = circuit;
        } else {
            const parentPath = path.slice(0, -1);
            let parentComponent = circuit;
            for (let i=0; i < parentPath.length; i++) {
                if (parentComponent[parentPath[i]]) {
                    parentComponent = parentComponent[parentPath[i]];
                } else if (parentComponent.branches && parentComponent.branches[parentPath[i]]) {
                     parentComponent = parentComponent.branches[parentPath[i]];
                }
            }
            parentCollection = parentComponent;
        }
        
        if (parentCollection && Array.isArray(parentCollection)) {
            parentCollection.splice(indexToRemove, 1);
        } else {
            const parentData = getParentByPath(path);
            if (Array.isArray(parentData.parent)) {
                 parentData.parent.splice(parentData.index, 1);
            } else if (parentData.parent.branches) {
                 parentData.parent.branches[path[path.length -2]].splice(parentData.index,1);
            }
        }

        renderControls();
        drawAndCalculate();
    }
    
    function parseResistanceValue(valueStr) {
        if (typeof valueStr !== 'string' || !valueStr) return null;
        const lastChar = valueStr.slice(-1).toLowerCase();
        let numPart = valueStr;
        let multiplier = 1;

        if (lastChar === 'k') {
            multiplier = 1e3;
            numPart = valueStr.slice(0, -1);
        } else if (lastChar === 'm') {
            multiplier = 1e6;
            numPart = valueStr.slice(0, -1);
        }

        const num = parseFloat(numPart);
        if (isNaN(num)) return null;

        return num * multiplier;
    }

    function updateResistorValue(pathStr, value) {
        const path = JSON.parse(pathStr);
        const component = getComponentByPath(path);
        if (component && component.type === 'resistor') {
            const parsedValue = parseResistanceValue(value);
            component.value = parsedValue !== null && parsedValue > 0 ? parsedValue : null;
            drawAndCalculate();
        }
    }
    
    function addBranch(pathStr) {
        const path = JSON.parse(pathStr);
        const component = getComponentByPath(path);
        component.branches.push([]);
        renderControls();
        drawAndCalculate();
    }

    function removeBranch(pathStr, branchIndex) {
        const path = JSON.parse(pathStr);
        const component = getComponentByPath(path);
        if (component.branches.length > 1) {
            component.branches.splice(branchIndex, 1);
            renderControls();
            drawAndCalculate();
        }
    }

    function toggleNamingConvention() {
        useSequentialNaming = !useSequentialNaming;
        const btn = document.getElementById('naming-toggle-btn');
        btn.textContent = useSequentialNaming ? 'Sequential (R1, R2...)' : 'Hierarchical (R1.1.1)';
        drawAndCalculate({force: true});
    }

    // --- UI RENDERING (RECURSIVE) ---

    function renderControls() {
        const builder = document.getElementById('circuit-builder');
        builder.innerHTML = '';
        circuit.forEach((component, index) => {
            builder.appendChild(renderComponent(component, [index]));
        });
    }

    function renderComponent(component, path) {
        const div = document.createElement('div');
        const pathStr = JSON.stringify(path);
        const level = Math.floor(path.length / 2);

        let title, baseClass, titleColor;

        if (component.type === 'resistor') {
            title = `Resistor`;
            baseClass = 'control-panel';
            titleColor = 'text-main';
        } else { // parallel
            title = level === 0 ? `Parallel Group` : `Nested Parallel Group`;
            baseClass = level === 0 ? 'component-group' : 'nested-component-group';
            titleColor = level === 0 ? 'header-text' : 'text-accent-color';
        }

        div.className = `p-4 rounded-lg border border-main shadow-sm transition-all ${baseClass}`;
        
        let innerHTML = `
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold ${titleColor}">${title}</h3>
                <button onclick="removeComponent('${pathStr}')" class="bg-red-500 text-white font-bold w-8 h-8 rounded-full hover:bg-red-600 transition transform hover:scale-110 flex items-center justify-center">&times;</button>
            </div>`;

        if (component.type === 'resistor') {
            innerHTML += `<div class="flex items-center p-2 rounded-md border border-main" style="background-color: var(--bg-primary);">
                <label class="font-medium text-light mr-2 whitespace-nowrap">R:</label>
                <input type="text" value="${component.value || ''}" 
                       oninput="updateResistorValue('${pathStr}', this.value)" 
                       placeholder="e.g., 100, 2.2k, 1M"
                       class="w-full p-1 border-0 rounded-md focus:ring-1">
            </div>`;
        } else { // parallel group
            innerHTML += '<div class="space-y-3">';
            component.branches.forEach((branch, bIndex) => {
                innerHTML += `
                    <div class="branch-bg p-3 rounded-lg border branch-border">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="font-semibold text-accent-color">Branch ${bIndex + 1}</h4>
                            ${component.branches.length > 1 ? `<button onclick="removeBranch('${pathStr}', ${bIndex})" class="text-red-500 hover:text-red-700 text-xs font-bold px-2 py-1 rounded-md bg-red-100 hover:bg-red-200 dark:bg-red-900/50 dark:hover:bg-red-900/80">Remove Branch</button>` : ''}
                        </div>
                        <div class="pl-4 border-l-2 border-main space-y-3" id="branch-${path.join('-')}-${bIndex}"></div>
                        <div class="mt-3 pt-2 border-t border-main flex flex-wrap gap-2">
                            <button onclick="addComponent('resistor', '${JSON.stringify([...path, bIndex])}')" class="bg-green-500 text-white text-xs font-semibold py-1 px-2 rounded hover:bg-green-600 transition">+ Resistor</button>
                            <button onclick="addComponent('parallel', '${JSON.stringify([...path, bIndex])}')" class="bg-cyan-500 text-white text-xs font-semibold py-1 px-2 rounded hover:bg-cyan-600 transition">+ Nested Parallel</button>
                        </div>
                    </div>`;
            });
            innerHTML += '</div>';
            innerHTML += `<div class="mt-4 pt-4 border-t border-main">
                <button onclick="addBranch('${pathStr}')" class="bg-purple-600 text-white text-sm font-semibold py-1 px-3 rounded-md hover:bg-purple-700 transition">+ Add Parallel Branch</button>
            </div>`;
        }

        div.innerHTML = innerHTML;
        
        if (component.type === 'parallel') {
            component.branches.forEach((branch, bIndex) => {
                const branchContainer = div.querySelector(`#branch-${path.join('-')}-${bIndex}`);
                branch.forEach((subComponent, cIndex) => {
                    branchContainer.appendChild(renderComponent(subComponent, [...path, bIndex, cIndex]));
                });
            });
        }

        return div;
    }


    // --- CALCULATION & EXPLANATION LOGIC (REWRITTEN) ---

    function calculateAndAnnotate(voltage) {
        if (isNaN(voltage) || voltage <= 0) return null;

        // Deep copy circuit to avoid modifying the original with calculation data
        const circuitToAnalyze = JSON.parse(JSON.stringify(circuit));

        function calculateReq(component) {
            if (component.type === 'resistor') {
                component.Req = component.value > 0 ? component.value : 0;
            } else if (component.type === 'parallel') {
                const branchResistances = component.branches.map(branch => {
                    let branchR = 0;
                    branch.forEach(subComp => {
                        calculateReq(subComp);
                        branchR += subComp.Req;
                    });
                    return branchR;
                }).filter(r => r > 0);

                if (branchResistances.length === 0) {
                    component.Req = 0;
                } else {
                    const inverseSum = branchResistances.reduce((sum, r) => sum + (1 / r), 0);
                    component.Req = 1 / inverseSum;
                }
            }
        }
        circuitToAnalyze.forEach(calculateReq);

        const totalResistance = circuitToAnalyze.reduce((sum, comp) => sum + comp.Req, 0);
        if (totalResistance === 0) return null;
        
        const totalCurrent = voltage / totalResistance;

        let resistorCounter = 0;
        const resistorList = [];

        function annotate(component, current, nameInfo) {
            if (!component || component.Req === 0) return;
            
            component.I = current;
            component.V = current * component.Req;
            component.P = component.V * component.I;

            if (component.type === 'resistor') {
                resistorCounter++;
                component.name = useSequentialNaming ? `R${resistorCounter}` : nameInfo.name;
                resistorList.push(component);

            } else if (component.type === 'parallel') {
                component.name = `Group_${nameInfo.name}`;
                component.branches.forEach((branch, bIndex) => {
                    const branchR = branch.reduce((sum, c) => sum + c.Req, 0);
                    if (branchR > 0) {
                        const branchCurrent = component.V / branchR;
                        branch.forEach((subComp, cIndex) => {
                            annotate(subComp, branchCurrent, {
                                name: `${nameInfo.name}.${bIndex + 1}.${cIndex + 1}`,
                                level: nameInfo.level + 1
                            });
                        });
                    }
                });
            }
        }

        circuitToAnalyze.forEach((component, index) => {
            annotate(component, totalCurrent, { name: `C${index + 1}`, level: 0 });
        });

        return {
            totalResistance,
            totalCurrent,
            totalPower: voltage * totalCurrent,
            resistors: resistorList,
            annotatedCircuit: circuitToAnalyze
        };
    }

    function calculateVIRP() {
        const voltage = parseFloat(document.getElementById('voltage').value);
        const resultsContainer = document.getElementById('results-container');
        const explanationSection = document.getElementById('explanation-section');
        
        if (isNaN(voltage) || voltage <= 0) {
            resultsContainer.innerHTML = `<p class="text-center text-red-600 font-semibold">Please enter a valid, positive source voltage.</p>`;
            explanationSection.style.display = 'none';
            return;
        }

        const analysis = calculateAndAnnotate(voltage);
        
        if (!analysis) {
            resultsContainer.innerHTML = `<p class="text-center text-yellow-600 font-semibold">Circuit is incomplete or has a short. Add components and resistor values.</p>`;
            explanationSection.style.display = 'none';
            return;
        }
        
        let resultsHTML = `
            <h2 class="text-2xl font-bold text-center mb-4" style="color: var(--heading-color);">V.I.R.P. Chart</h2>
            <div class="overflow-x-auto shadow-md rounded-lg">
                <table class="w-full text-sm text-left text-light">
                    <thead class="text-xs text-main uppercase" style="background-color: var(--bg-secondary);">
                        <tr>
                            <th scope="col" class="px-6 py-3">Component</th>
                            <th scope="col" class="px-6 py-3 text-right">Voltage</th>
                            <th scope="col" class="px-6 py-3 text-right">Current</th>
                            <th scope="col" class="px-6 py-3 text-right">Resistance (Ω)</th>
                            <th scope="col" class="px-6 py-3 text-right">Power</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        analysis.resistors.forEach(resistor => {
            resultsHTML += `<tr class="border-b border-main" style="background-color: var(--bg-primary);">
                <td class="px-6 py-4 font-medium text-main">${resistor.name}</td>
                <td class="px-6 py-4 text-right">${formatValue(resistor.V, 'V')}</td>
                <td class="px-6 py-4 text-right">${formatValue(resistor.I, 'A')}</td>
                <td class="px-6 py-4 text-right">${resistor.value}</td>
                <td class="px-6 py-4 text-right">${formatValue(resistor.P, 'W')}</td>
            </tr>`;
        });

        resultsHTML += `
                <tr class="font-bold text-main" style="background-color: var(--bg-secondary);">
                    <td class="px-6 py-4">Total</td>
                    <td class="px-6 py-4 text-right">${formatValue(voltage, 'V')}</td>
                    <td class="px-6 py-4 text-right">${formatValue(analysis.totalCurrent, 'A')}</td>
                    <td class="px-6 py-4 text-right">${analysis.totalResistance.toFixed(3)}</td>
                    <td class="px-6 py-4 text-right">${formatValue(analysis.totalPower, 'W')}</td>
                </tr>
            </tbody></table></div>`;
        resultsContainer.innerHTML = resultsHTML;

        if (circuit.length > 0) {
            explanationSection.style.display = 'block';
            const explanationContent = document.getElementById('explanation-content');
            explanationContent.innerHTML = generateExplanationHtml(analysis.annotatedCircuit, voltage);
        } else {
            explanationSection.style.display = 'none';
        }
    }

    function toggleExplanation() {
        const content = document.getElementById('explanation-content');
        const btn = document.getElementById('explain-btn');
        const isVisible = content.style.display === 'block';
        
        if (isVisible) {
            content.style.display = 'none';
            btn.textContent = 'Explain Equations';
        } else {
            content.style.display = 'block';
            btn.textContent = 'Hide Equations';
        }
    }

    function generateExplanationHtml(annotatedCircuit, sourceVoltage) {
        if (!annotatedCircuit || annotatedCircuit.length === 0) return '<p>The circuit is empty.</p>';
        
        let html = '<h3 class="font-bold text-xl mb-3 text-main">Calculation Walkthrough</h3>';
        let counters = { resistor: 1, parallelGroup: 1, seriesGroup: 1 };
        
        // --- STEP 1: Calculate Total Resistance ---
        html += '<h4 class="font-semibold text-lg mt-4 mb-2 text-accent-color">Step 1: Simplify to find Total Resistance (R<sub>Total</sub>)</h4>';
        html += '<p class="text-sm text-light mb-3">We simplify the circuit by combining resistors, starting from the most nested parts.</p>';
        html += '<div class="space-y-3 text-sm">';

        function getResistanceExplanation(component) {
            if (component.type === 'resistor') {
                const name = `R${counters.resistor++}`;
                component.calcName = name; // Store the name for later reference
                return { name: name, steps: [] };
            }

            if (component.type === 'parallel') {
                const groupName = `R_p${counters.parallelGroup++}`;
                component.calcName = groupName;
                let groupSteps = [];
                let branchCalculations = [];

                component.branches.forEach((branch, i) => {
                    if (branch.length === 0) return;
                    
                    const branchTotalR = branch.reduce((s,c)=>s+c.Req, 0);
                    if (branchTotalR === 0) return;

                    if (branch.length > 1) { // It's a series of components within a branch
                        const seriesGroupName = `R_s${counters.seriesGroup++}`;
                        let seriesResistors = [];
                        let seriesValues = [];
                        branch.forEach(subComp => {
                            const subResult = getResistanceExplanation(subComp);
                            groupSteps.push(...subResult.steps);
                            seriesResistors.push(subResult.name);
                            seriesValues.push(subComp.Req);
                        });
                        
                        const equation = `${seriesGroupName} = ${seriesResistors.join(' + ')}`;
                        const values = `${seriesGroupName} = ${seriesValues.map(v => `${v.toFixed(2)}Ω`).join(' + ')} = ${branchTotalR.toFixed(2)}Ω`;
                        groupSteps.push(`<li>First, combine series resistors in branch ${i+1}: <code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${equation}</code><code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${values}</code></li>`);
                        branchCalculations.push({name: seriesGroupName, value: branchTotalR});

                    } else { // Single component in the branch
                        const subResult = getResistanceExplanation(branch[0]);
                        groupSteps.push(...subResult.steps);
                        branchCalculations.push({name: subResult.name, value: branch[0].Req});
                    }
                });
                
                if(branchCalculations.length > 0) {
                    const inverseTerms = branchCalculations.map(b => `1/${b.name}`).join(' + ');
                    const inverseValues = branchCalculations.map(b => `1/${b.value.toFixed(2)}Ω`).join(' + ');
                    const equation = `${groupName} = 1 / (${inverseTerms})`;
                    const values = `${groupName} = 1 / (${inverseValues}) = ${component.Req.toFixed(2)}Ω`;
                    groupSteps.push(`<li>Combine the parallel branches: <code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${equation}</code><code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${values}</code></li>`);
                }
                
                return { name: groupName, steps: groupSteps };
            }
            return {name: '', steps:[]};
        }

        counters.resistor = 1; 
        let finalResistanceSteps = [];
        let topLevelComponents = [];
        let topLevelValues = [];

        annotatedCircuit.forEach(component => {
            if (component.Req > 0) {
                const result = getResistanceExplanation(component);
                finalResistanceSteps.push(...result.steps);
                topLevelComponents.push(result.name);
                topLevelValues.push(component.Req);
            }
        });

        html += `<ol class="list-decimal list-inside space-y-2">${finalResistanceSteps.join('')}</ol>`;
        
        const totalReq = annotatedCircuit.reduce((s, c) => s + c.Req, 0);
        const totalFormula = `R<sub>Total</sub> = ${topLevelComponents.join(' + ')}`;
        const totalValues = `R<sub>Total</sub> = ${topLevelValues.map(v => `${v.toFixed(2)}Ω`).join(' + ')} = <strong>${totalReq.toFixed(2)}Ω</strong>`;
        html += `<div class="mt-3 p-3 rounded bg-sky-100 dark:bg-sky-900/50 border border-sky-200 dark:border-sky-700">
                    <p class="font-semibold">Finally, add the top-level components:</p>
                    <code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${totalFormula}</code>
                    <code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${totalValues}</code>
                </div>`;
        html += '</div>';

        // --- STEP 2: Calculate Total Current ---
        html += '<h4 class="font-semibold text-lg mt-6 mb-2 text-accent-color">Step 2: Find Total Current (I<sub>Total</sub>)</h4>';
        html += '<p class="text-sm text-light mb-3">Using Ohm\'s Law (V = IR), we find the total current flowing from the source.</p>';
        const totalCurrent = sourceVoltage / totalReq;
        const currentFormula = `I<sub>Total</sub> = V<sub>Source</sub> / R<sub>Total</sub>`;
        const currentValues = `I<sub>Total</sub> = ${sourceVoltage}V / ${totalReq.toFixed(2)}Ω = <strong>${formatValue(totalCurrent, 'A')}</strong>`;
        html += `<div class="p-3 rounded bg-sky-100 dark:bg-sky-900/50 border border-sky-200 dark:border-sky-700">
                    <code class="block p-2 rounded bg-white dark:bg-slate-800">${currentFormula}</code>
                    <code class="block mt-1 p-2 rounded bg-white dark:bg-slate-800">${currentValues}</code>
                </div>`;

        // --- STEP 3: Analyze Individual Components ---
        html += '<h4 class="font-semibold text-lg mt-6 mb-2 text-accent-color">Step 3: Calculate V, I, and P for Each Resistor</h4>';
        html += '<p class="text-sm text-light mb-3">Now we work backwards, applying the rules for series and parallel circuits.</p>';
        html += '<div class="space-y-4">';

        function getVIPExplanation(component, current) {
            let compHtml = '';
            if (component.type === 'resistor') {
                compHtml += `<div class="p-3 rounded border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-900/50">
                    <p class="font-semibold text-main">Analyzing ${component.name} (${component.value}Ω):</p>
                    <ul class="list-disc list-inside text-sm mt-2 space-y-1 pl-2">
                        <li>Current (I) is <strong>${formatValue(current, 'A')}</strong> (from its series section).</li>
                        <li>Voltage (V) = I × R = ${formatValue(current, 'A')} × ${component.value}Ω = <strong>${formatValue(component.V, 'V')}</strong>.</li>
                        <li>Power (P) = V × I = ${formatValue(component.V, 'V')} × ${formatValue(current, 'A')} = <strong>${formatValue(component.P, 'W')}</strong>.</li>
                    </ul>
                </div>`;
            } else if (component.type === 'parallel') {
                compHtml += `<div class="p-3 rounded border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-900/50">
                    <p class="font-semibold text-main">Analyzing Parallel Group ${component.calcName} (R<sub>eq</sub>: ${component.Req.toFixed(2)}Ω):</p>
                    <ul class="list-disc list-inside text-sm mt-2 space-y-2 pl-2">
                        <li>The total current entering the group is ${formatValue(current, 'A')}.</li>
                        <li>Voltage across the group is V = I × R<sub>eq</sub> = ${formatValue(current, 'A')} × ${component.Req.toFixed(2)}Ω = <strong>${formatValue(component.V, 'V')}</strong>.</li>
                        <li>This voltage is <strong>the same</strong> for all branches inside this parallel group.</li>
                    </ul>
                    <div class="mt-3 space-y-3 pl-4 border-l-2 border-sky-300 dark:border-sky-700">`;

                component.branches.forEach((branch, i) => {
                    const branchR = branch.reduce((sum, c) => sum + c.Req, 0);
                    if (branchR > 0) {
                        const branchCurrent = component.V / branchR;
                        compHtml += `<div class="p-2 rounded bg-white dark:bg-slate-800">
                            <p class="font-medium text-accent-color">Branch ${i+1} (Total R = ${branchR.toFixed(2)}Ω):</p>
                            <p class="text-xs ml-4">Current (I<sub>branch</sub>) = V<sub>group</sub> / R<sub>branch</sub> = ${formatValue(component.V, 'V')} / ${branchR.toFixed(2)}Ω = <strong>${formatValue(branchCurrent, 'A')}</strong>.</p>
                            <div class="mt-2 space-y-2">`;
                        
                        branch.forEach(subComp => {
                            compHtml += getVIPExplanation(subComp, branchCurrent);
                        });

                        compHtml += '</div></div>';
                    }
                });
                compHtml += '</div></div>';
            }
            return compHtml;
        }
        
        annotatedCircuit.forEach(component => {
            html += getVIPExplanation(component, totalCurrent);
        });

        html += '</div>';

        return html;
    }


    // --- DRAWING LOGIC (RECURSIVE & INTERACTIVE) ---

    function drawAndCalculate(options = {force: false}) {
        clearTimeout(window.drawTimeout);
        window.drawTimeout = setTimeout(() => {
            drawCircuit();
            calculateVIRP();
        }, options.force ? 0 : 300);
    }
    
    function getComponentDimensions(component) {
        const rWidth = 60, pGapY = 60, pGapX = 20, seriesGap = 20;
        if (component.type === 'resistor') {
            return { width: rWidth, height: 50 };
        }
        if (component.type === 'parallel') {
            let maxWidth = 0;
            let totalHeight = 0;
            const branchDimensions = component.branches.map(branch => {
                let branchWidth = 0;
                let maxHeight = 50; // min height for empty branch
                branch.forEach((subComp, i) => {
                    const dims = getComponentDimensions(subComp);
                    branchWidth += dims.width;
                    if(i > 0) branchWidth += seriesGap;
                    if(dims.height > maxHeight) maxHeight = dims.height;
                });
                return { width: branchWidth, height: maxHeight };
            });

            branchDimensions.forEach((dims, i) => {
                if (dims.width > maxWidth) maxWidth = dims.width;
                totalHeight += dims.height;
                 if(i > 0) totalHeight += pGapY;
            });
            
            return { width: maxWidth + pGapX * 2, height: Math.max(totalHeight, 50) };
        }
        return { width: 0, height: 0 };
    }

    function drawCircuit() {
        drawableComponents = []; // Clear for hit detection
        const totalDimensions = getComponentDimensions({type: 'parallel', branches: [circuit]});
        const requiredWidth = totalDimensions.width + 200;
        
        canvas.width = Math.max(canvas.parentElement.offsetWidth, requiredWidth);
        canvas.height = totalDimensions.height + 100;
        
        const voltageValue = document.getElementById('voltage').value || 'V';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = 2; ctx.font = '14px Inter'; ctx.textAlign = 'center';
        
        const startX = 60;
        const startY = canvas.height / 2;

        let resistorCounter = 0;

        const isPathActive = !isolatedComponentPath;

        drawBattery(startX, startY, voltageValue + 'V', isPathActive, ['source']);

        let currentX = startX + 40;
        ctx.beginPath(); 
        
        circuit.forEach((component, index) => {
            const dims = getComponentDimensions(component);
            const path = [index];
            let componentIsActive = isPathActive;
            if (isolatedComponentPath) {
                 componentIsActive = true;
            }

            setDrawStyle(isPathActive, path);
            ctx.moveTo(currentX, startY);
            currentX += 20;
            ctx.lineTo(currentX, startY);
            ctx.stroke();

            resistorCounter = drawComponentOnCanvas(component, currentX, startY, { name: `R${index + 1}` }, resistorCounter, path, componentIsActive);
            currentX += dims.width;
            
            setDrawStyle(isPathActive, path);
            ctx.beginPath();
            ctx.moveTo(currentX, startY);
        });

        const endX = currentX + 40;
        setDrawStyle(isPathActive, ['end']);
        ctx.lineTo(endX, startY);
        ctx.lineTo(endX, canvas.height - 20);
        ctx.lineTo(20, canvas.height - 20);
        ctx.lineTo(20, startY);
        ctx.lineTo(startX - 20, startY);
        ctx.stroke();
    }
    
    function drawComponentOnCanvas(component, x, y, namePrefix, counter, path, isPathActive) {
        if (component.type === 'resistor') {
            counter++;
            const resistorName = useSequentialNaming ? `R${counter}` : namePrefix.name;
            drawResistor(x, y, resistorName, component.value, isPathActive, path);
            return counter;
        }

        if (component.type === 'parallel') {
            const groupDims = getComponentDimensions(component);
            const pStartX = x;
            const pEndX = x + groupDims.width;
            
            const branchDims = component.branches.map(b => getComponentDimensions({type: 'parallel', branches: [b]}));
            const totalBranchHeight = branchDims.reduce((sum, d) => sum + d.height, 0);
            const totalGaps = (component.branches.length - 1) * 60; // pGapY = 60
            const pTotalHeight = totalBranchHeight + totalGaps;

            let currentY = y - pTotalHeight / 2;
            
            ctx.beginPath();
            setDrawStyle(isPathActive, path);
            ctx.moveTo(pStartX, y + pTotalHeight / 2);
            ctx.lineTo(pStartX, y - pTotalHeight/2);
            ctx.moveTo(pEndX, y + pTotalHeight / 2);
            ctx.lineTo(pEndX, y - pTotalHeight / 2);
            ctx.stroke();

            component.branches.forEach((branch, bIndex) => {
                const branchPath = [...path, bIndex];
                const branchHeight = branchDims[bIndex].height;
                const branchY = currentY + branchHeight / 2;
                const pGapX = 20, seriesGap = 20;

                let branchIsActive = isPathActive;
                if(isolatedComponentPath){
                    branchIsActive = isPathActive && isolatedComponentPath.length > path.length && isolatedComponentPath[path.length] === bIndex;
                }

                ctx.beginPath();
                setDrawStyle(branchIsActive, branchPath);
                ctx.moveTo(pStartX, branchY);
                ctx.lineTo(pStartX + pGapX, branchY);
                ctx.stroke();

                let branchCurrentX = pStartX + pGapX;
                
                branch.forEach((subComp, i) => {
                    const subPath = [...branchPath, i];
                    const subDims = getComponentDimensions(subComp);
                    const newName = `${namePrefix.name}.${bIndex + 1}.${i + 1}`;
                    
                    counter = drawComponentOnCanvas(subComp, branchCurrentX, branchY, { name: newName }, counter, subPath, branchIsActive);
                    branchCurrentX += subDims.width;

                    ctx.beginPath();
                    setDrawStyle(branchIsActive, subPath);
                    ctx.moveTo(branchCurrentX, branchY);
                    if (i < branch.length - 1) {
                         branchCurrentX += seriesGap;
                         ctx.lineTo(branchCurrentX, branchY);
                    }
                     ctx.stroke();
                });
                
                ctx.beginPath();
                setDrawStyle(branchIsActive, branchPath);
                ctx.lineTo(pEndX - pGapX, branchY);
                ctx.moveTo(pEndX, branchY);
                ctx.stroke();

                currentY += branchHeight + 60; // pGapY
            });
            return counter;
        }
        return counter;
    }
    
    function setDrawStyle(isActive, path) {
        const isDark = document.documentElement.classList.contains('dark');
        const defaultStroke = isDark ? '#e2e8f0' : '#334155';
        const highlightStroke = getComputedStyle(document.documentElement).getPropertyValue('--highlight-stroke').trim();
        const hoverStroke = getComputedStyle(document.documentElement).getPropertyValue('--hover-stroke').trim();

        ctx.globalAlpha = isActive ? 1.0 : 0.2;
        ctx.strokeStyle = defaultStroke;
        ctx.fillStyle = defaultStroke;

        if (isolatedComponentPath && JSON.stringify(path) === JSON.stringify(isolatedComponentPath)) {
            ctx.strokeStyle = highlightStroke;
            ctx.fillStyle = highlightStroke;
        }
        if (hoveredComponentPath && JSON.stringify(path) === JSON.stringify(hoveredComponentPath)) {
            ctx.strokeStyle = hoverStroke;
            ctx.fillStyle = hoverStroke;
            ctx.globalAlpha = 1.0;
        }
    }

    function drawBattery(x, y, label, isActive, path) { 
        ctx.beginPath(); 
        setDrawStyle(isActive, path);
        ctx.moveTo(x - 20, y); ctx.lineTo(x, y); ctx.moveTo(x + 5, y - 12); ctx.lineTo(x + 5, y + 12); ctx.moveTo(x + 15, y - 20); ctx.lineTo(x + 15, y + 20); ctx.moveTo(x + 20, y); ctx.lineTo(x + 40, y); ctx.stroke(); ctx.fillText(label, x + 10, y - 25); 
    }
    function drawResistor(x, y, label, value, isActive, path) { 
        const width = 60, height = 16, lead = 5; 
        drawableComponents.push({path, x, y: y - height, width, height: height * 2});

        const zigzagWidth = width - 2 * lead, numPeaks = 3, segments = numPeaks * 2; const segWidth = zigzagWidth / segments; let currentZigzagX = x + lead; 
        
        ctx.beginPath();
        setDrawStyle(isActive, path);
        ctx.moveTo(x, y); ctx.lineTo(currentZigzagX, y); 
        for (let i = 0; i < segments; i++) { const yOffset = (i % 2 === 0) ? -height/2 : height/2; currentZigzagX += segWidth; ctx.lineTo(currentZigzagX, y + yOffset); } 
        ctx.lineTo(x + width, y);
        ctx.stroke();

        ctx.fillText(label, x + width/2, y - 20); 
        ctx.fillText((value || '?') + ' Ω', x + width/2, y + 25);
    }
    function formatValue(value, unit) { if (typeof value !== 'number' || isNaN(value)) return 'N/A'; if (value === 0) return `0 ${unit}`; const absValue = Math.abs(value); if (unit === 'A' || unit === 'W' || unit === 'V') { if (absValue < 1e-6) return (value * 1e9).toFixed(2) + ` n${unit}`; if (absValue < 1e-3) return (value * 1e6).toFixed(2) + ` µ${unit}`; if (absValue < 1) return (value * 1000).toFixed(2) + ` m${unit}`; } if (absValue >= 1e6) return (value / 1e6).toFixed(2) + ` M${unit}`; if (absValue >= 1e3) return (value / 1e3).toFixed(2) + ` k${unit}`; return value.toFixed(3) + ` ${unit}`; }

    // --- CANVAS INTERACTIVITY ---
    function handleCanvasClick(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        for (let i = drawableComponents.length - 1; i >= 0; i--) {
            const comp = drawableComponents[i];
            if (mouseX >= comp.x && mouseX <= comp.x + comp.width && 
                mouseY >= comp.y && mouseY <= comp.y + comp.height) {
                
                const pathStr = JSON.stringify(comp.path);
                if (isolatedComponentPath && JSON.stringify(isolatedComponentPath) === pathStr) {
                    isolatedComponentPath = null; // Toggle off
                } else {
                    isolatedComponentPath = comp.path;
                }
                document.getElementById('reset-view-btn').style.display = isolatedComponentPath ? 'block' : 'none';
                drawCircuit();
                return;
            }
        }
    }

    function handleCanvasMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        let newHoveredPath = null;
        let onComponent = false;

        for (let i = drawableComponents.length - 1; i >= 0; i--) {
            const comp = drawableComponents[i];
            if (mouseX >= comp.x && mouseX <= comp.x + comp.width && 
                mouseY >= comp.y && mouseY <= comp.y + comp.height) {
                newHoveredPath = comp.path;
                onComponent = true;
                break;
            }
        }
        
        canvas.style.cursor = onComponent ? 'pointer' : 'default';

        if (JSON.stringify(newHoveredPath) !== JSON.stringify(hoveredComponentPath)) {
            hoveredComponentPath = newHoveredPath;
            drawCircuit();
        }
    }

    function handleCanvasMouseLeave() {
        if(hoveredComponentPath){
            hoveredComponentPath = null;
            drawCircuit();
        }
    }

    function resetIsolationView() {
        isolatedComponentPath = null;
        document.getElementById('reset-view-btn').style.display = 'none';
        drawAndCalculate({force: true});
    }

    // --- CIRCUIT DATA MANAGEMENT ---
    function saveCircuit() { // Saves to browser's localStorage
        if (circuit.length > 0) {
            localStorage.setItem('userSavedCircuit', JSON.stringify(circuit));
            alert('Circuit saved to your browser!');
        } else {
            alert('Cannot save an empty circuit to browser.');
        }
    }

    function loadCircuit() { // Loads from browser's localStorage
        const savedCircuit = localStorage.getItem('userSavedCircuit');
        if (savedCircuit) {
            try {
                const parsedCircuit = JSON.parse(savedCircuit);
                 if (Array.isArray(parsedCircuit)) {
                    circuit = parsedCircuit;
                    resetIsolationView();
                    renderControls();
                    drawAndCalculate({ force: true });
                } else {
                     alert('Saved circuit data is invalid.');
                }
            } catch(e) {
                 alert('Could not load circuit from browser. Data might be corrupted.');
            }
        } else {
            alert('No saved circuit found in your browser.');
        }
    }
    
    function exportCircuit() { // Exports to a .json file
        if (circuit.length === 0) {
            alert('Cannot export an empty circuit.');
            return;
        }

        const circuitData = JSON.stringify(circuit, null, 2);
        const blob = new Blob([circuitData], { type: 'application/json' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = 'circuit-layout.json';
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }

    function importCircuit() { // Imports from a .json file
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,application/json';

        fileInput.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    if (Array.isArray(importedData)) {
                        circuit = importedData;
                        resetIsolationView();
                        renderControls();
                        drawAndCalculate({ force: true });
                        alert('Circuit imported successfully!');
                    } else {
                        throw new Error('Invalid circuit file format. Must be an array.');
                    }
                } catch (error) {
                    console.error('Error importing circuit:', error);
                    alert('Could not import circuit. The file might be corrupted or in the wrong format.');
                }
            };
            
            reader.onerror = error => {
                console.error('Error reading file:', error);
                alert('An error occurred while reading the file.');
            };
            reader.readAsText(file);
        };
        fileInput.click();
    }

    // --- CIRCUIT BUILDER FUNCTIONS ---
    function clearCircuit(redraw = true) {
        circuit = [];
        resetIsolationView();
        if (redraw) {
            renderControls();
            drawAndCalculate({force: true});
        }
    }

    function simplifyCircuit() {
        // We need the equivalent resistance, which our new function can provide.
        const analysis = calculateAndAnnotate(parseFloat(document.getElementById('voltage').value) || 1);
        
        if (analysis && analysis.totalResistance > 0) {
            clearCircuit(false);
            addComponent('resistor', '[]'); 

            // Find the new resistor object in the modified 'circuit' array
            const newResistor = getComponentByPath([0]);
            if (newResistor) {
                // Update the value directly in the component object before rendering
                newResistor.value = parseFloat(analysis.totalResistance.toFixed(3));
            }
            renderControls();
            drawAndCalculate({force: true});
        }
    }
    
    function buildLadderCircuit() {
        clearCircuit(false);
        // R1
        addComponent('resistor', '[]');
        updateResistorValue('[0]', "100");
        
        addComponent('parallel', '[]');
        addComponent('resistor', '[1, 0]'); // R2
        updateResistorValue('[1, 0, 0]', "100");

        // Branch 2
        addComponent('resistor', '[1, 1]');
        updateResistorValue('[1, 1, 0]', "100");
        addComponent('parallel', '[1, 1]');
        addComponent('resistor', '[1, 1, 1, 0]'); // R4
        updateResistorValue('[1, 1, 1, 0, 0]', "100");
        addComponent('resistor', '[1, 1, 1, 1]'); // R5
        updateResistorValue('[1, 1, 1, 1, 0]', "100");

        // R6
        addComponent('resistor', '[]');
        updateResistorValue('[2]', "100");
        
        renderControls();
        drawAndCalculate({force: true});
    }

    function buildNestedExample() {
        clearCircuit(false);
        addComponent('resistor');
        updateResistorValue('[0]', "100");

        addComponent('parallel');
        
        addComponent('resistor', '[1, 0]');
        updateResistorValue('[1, 0, 0]', "500");
        
        addComponent('resistor', '[1, 1]');
        updateResistorValue('[1, 1, 0]', "250");
        addComponent('parallel', '[1, 1]');
        
        addComponent('resistor', '[1, 1, 1, 0]');
        updateResistorValue('[1, 1, 1, 0, 0]', "200");

        addComponent('resistor', '[1, 1, 1, 1]'); 
        addComponent('resistor', '[1, 1, 1, 1]'); 
        updateResistorValue('[1, 1, 1, 1, 0]', "150");
        updateResistorValue('[1, 1, 1, 1, 1]', "50");

        renderControls();
        drawAndCalculate({force: true});
    }

    // --- CAT POPUP LOGIC ---
    const catPopup = document.getElementById('cat-popup');
    const catPopupContent = catPopup.querySelector('.transform');
    const catImageContainer = document.getElementById('cat-image-container');

    function showCatPopup() {
        catPopup.style.display = 'flex';
        // Use a short timeout to allow the display property to apply before starting the transition
        setTimeout(() => {
            catPopup.classList.remove('opacity-0');
            catPopupContent.classList.remove('scale-95');
        }, 10);
        loadNewCat();
    }

    function hideCatPopup() {
        catPopup.classList.add('opacity-0');
        catPopupContent.classList.add('scale-95');
        // Wait for the transition to finish before hiding the element
        setTimeout(() => {
            catPopup.style.display = 'none';
            catImageContainer.innerHTML = '<p class="text-light animate-pulse">Loading a cute cat...</p>';
        }, 300);
    }

    function loadNewCat() {
        catImageContainer.innerHTML = '<p class="text-light animate-pulse">Loading a cute cat...</p>';
        const img = new Image();
        // Add a timestamp to prevent caching and get a new cat every time
        img.src = `https://cataas.com/cat?_=${new Date().getTime()}`;
        img.className = 'w-full h-full object-contain rounded-md';
        img.onload = () => {
            catImageContainer.innerHTML = '';
            catImageContainer.appendChild(img);
        };
        img.onerror = () => {
            catImageContainer.innerHTML = '<p class="text-red-500 font-semibold">Could not load a cat. Sorry! 😿</p>';
        };
    }
    
    // Add event listener to close popup when clicking on the background overlay
    catPopup.addEventListener('click', function(event) {
        if (event.target === catPopup) {
            hideCatPopup();
        }
    });

    // --- INITIAL STATE ---
    window.onload = () => {
        buildLadderCircuit();
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
        // Prepare the popup for transitions
        catPopup.classList.add('opacity-0');
    };

    window.onresize = () => drawAndCalculate({force: true});
</script>

<script type="text/javascript" async src="https://tenor.com/embed.js"></script>
</body>
</html>
